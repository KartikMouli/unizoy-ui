{
  "$schema": "https://ui.unizoy.com/schema/registry-item.json",
  "name": "draggable-carousel",
  "type": "registry:ui",
  "author": "shadcn (https://ui.unizoy.com)",
  "dependencies": [
    "gsap",
    "@gsap/react"
  ],
  "files": [
    {
      "path": "ui/draggable-carousel.tsx",
      "content": "\"use client\"\nimport { useRef, useEffect } from \"react\"\nimport gsap from \"gsap\"\nimport { Draggable } from \"gsap/Draggable\"\nimport { useGSAP } from \"@gsap/react\"\n\nexport interface CarouselItem {\n  title: string\n  description: string\n  imageUrl: string\n}\n\ngsap.registerPlugin(Draggable)\n\ninterface DraggableCarouselProps {\n  items: CarouselItem[]\n  /**\n   * keep this number between 0-1\n   */\n  friction?: number\n  cardWidth?: string\n}\n\nexport default function DraggableCarousel({\n  items,\n  friction = 0.92,\n  cardWidth,\n}: DraggableCarouselProps) {\n  const carouselRef = useRef<HTMLDivElement>(null)\n  const wrapperRef = useRef<HTMLDivElement>(null)\n  const draggableInstanceRef = useRef<Draggable | null>(null)\n\n  // Tracking for custom inertia\n  const lastPositionsRef = useRef<Array<{ time: number; x: number }>>([])\n  const isThrowingRef = useRef(false)\n  const animationFrameRef = useRef<number | null>(null)\n\n  useGSAP(() => {\n    if (!carouselRef.current || !wrapperRef.current) return\n\n    const carousel = carouselRef.current\n    const wrapper = wrapperRef.current\n\n    // Calculate the total width of all cards\n    const totalWidth = wrapper.scrollWidth\n    const carouselWidth = carousel.offsetWidth\n    const maxX = -(totalWidth - carouselWidth)\n\n    // Clear position tracking array\n    lastPositionsRef.current = []\n\n    // Create draggable instance\n    const draggable = Draggable.create(wrapper, {\n      type: \"x\",\n      bounds: {\n        minX: maxX,\n        maxX: 0,\n      },\n      // Disable GSAP's built-in inertia\n      inertia: false,\n      dragResistance: 0,\n      edgeResistance: 0.9,\n      onDragStart: function () {\n        // Clear any ongoing inertia animation\n        if (animationFrameRef.current) {\n          cancelAnimationFrame(animationFrameRef.current)\n          animationFrameRef.current = null\n        }\n\n        isThrowingRef.current = false\n        lastPositionsRef.current = []\n      },\n      onDrag: function () {\n        // Track position and time for velocity calculation\n        const currentX = this.x\n        lastPositionsRef.current.push({\n          time: Date.now(),\n          x: currentX,\n        })\n\n        // Keep only the last 10 positions for accurate velocity calculation\n        if (lastPositionsRef.current.length > 10) {\n          lastPositionsRef.current.shift()\n        }\n      },\n      onDragEnd: function () {\n        // Calculate velocity from tracked positions\n        const positions = lastPositionsRef.current\n        if (positions.length < 2) return\n\n        const newest = positions[positions.length - 1]\n        const oldest = positions[Math.max(0, positions.length - 6)] // Use ~5 positions for smoother velocity\n\n        const timeDiff = newest.time - oldest.time\n        if (timeDiff === 0) return\n\n        // Calculate pixels per millisecond, then convert to pixels per frame\n        const velocity = ((newest.x - oldest.x) / timeDiff) * 16.67 // ~60fps\n\n        // Only apply inertia if there's significant velocity\n        if (Math.abs(velocity) > 0.5) {\n          applyInertia(velocity, this.x, maxX)\n        }\n      },\n    })[0]\n\n    draggableInstanceRef.current = draggable\n\n    // Custom inertia implementation\n    const applyInertia = (\n      initialVelocity: number,\n      startX: number,\n      minBound: number\n    ) => {\n      let velocity = initialVelocity\n      let currentX = startX\n      // const friction =friction; // Adjust for more or less \"slide\" - lower = faster slowdown\n\n      isThrowingRef.current = true\n\n      const animate = () => {\n        if (Math.abs(velocity) < 0.5 || !isThrowingRef.current) {\n          // Stop animation when velocity becomes very small\n          isThrowingRef.current = false\n          animationFrameRef.current = null\n\n          // Snap back if out of bounds\n          if (currentX > 0) {\n            gsap.to(wrapper, { x: 0, duration: 0.3, ease: \"power2.out\" })\n          } else if (currentX < minBound) {\n            gsap.to(wrapper, { x: minBound, duration: 0.3, ease: \"power2.out\" })\n          }\n\n          return\n        }\n\n        // Apply friction to slow down\n        velocity *= friction\n\n        // Update position\n        currentX += velocity\n\n        // Handle bouncing off boundaries\n        if (currentX > 0) {\n          // Bouncing off the start\n          velocity *= -0.5\n          currentX = 0\n        } else if (currentX < minBound) {\n          // Bouncing off the end\n          velocity *= -0.5\n          currentX = minBound\n        }\n\n        // Apply the new position\n        if (wrapper) {\n          gsap.set(wrapper, { x: currentX })\n\n          // Allow Draggable to update its internal state\n          if (draggableInstanceRef.current) {\n            draggableInstanceRef.current.update()\n          }\n        }\n\n        // Continue animation\n        animationFrameRef.current = requestAnimationFrame(animate)\n      }\n\n      // Start animation\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n      }\n      animationFrameRef.current = requestAnimationFrame(animate)\n    }\n\n    // Cleanup function\n    return () => {\n      // Kill the draggable instance\n      if (draggableInstanceRef.current) {\n        draggableInstanceRef.current.kill()\n        draggableInstanceRef.current = null\n      }\n\n      // Cancel any ongoing animation\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current)\n        animationFrameRef.current = null\n      }\n    }\n  })\n\n  // Allow interrupting the throw animation when user interacts\n  useEffect(() => {\n    const handleInterrupt = () => {\n      if (isThrowingRef.current) {\n        isThrowingRef.current = false\n      }\n    }\n\n    document.addEventListener(\"mousedown\", handleInterrupt)\n    document.addEventListener(\"touchstart\", handleInterrupt)\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleInterrupt)\n      document.removeEventListener(\"touchstart\", handleInterrupt)\n    }\n  }, [])\n\n  return (\n    <div\n      ref={carouselRef}\n      className=\"w-full overflow-hidden cursor-grab active:cursor-grabbing\"\n    >\n      <div ref={wrapperRef} className=\"flex gap-6 p-4\">\n        {items.map((item, index) => (\n          <div\n            key={index}\n            style={{ width: cardWidth ?? \"300px\" }}\n            className=\"flex-shrink-0 w-[300px] bg-white dark:bg-black rounded-xl border shadow-lg overflow-hidden transform transition-transform hover:scale-[1.02]\"\n          >\n            <div className=\"p-4\">\n              <h3 className=\"text-base font-semibold mb-2 text-gray-800 dark:text-white\">\n                {item.title}\n              </h3>\n              <p className=\"text-foregound text-sm\">{item.description}</p>\n            </div>\n            <div className=\"rounded-xl w-[90%] h-48 overflow-hidden my-3 mx-auto\">\n              <img\n                src={item.imageUrl}\n                alt={item.title}\n                className=\"w-full h-48 object-cover\"\n              />\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "categories": [
    "hover-effect"
  ]
}