{
  "$schema": "https://ui.unizoy.com/schema/registry-item.json",
  "name": "scrolling-cards",
  "type": "registry:ui",
  "author": "shadcn (https://ui.unizoy.com)",
  "dependencies": [
    "gsap",
    "@gsap/react"
  ],
  "files": [
    {
      "path": "ui/scrolling-cards.tsx",
      "content": "\"use client\"\nimport { ReactElement, RefObject, useEffect, useRef, useState } from \"react\"\nimport { useGSAP } from \"@gsap/react\"\nimport ScrollTrigger from \"gsap/ScrollTrigger\"\nimport gsap from \"gsap\"\n\ngsap.registerPlugin(ScrollTrigger)\n\ninterface CardSliderProps {\n  cards: {\n    card: ReactElement\n    rotate: number\n    transformOrigin?: string\n  }[]\n  cardWidth: number\n  top?: number\n  left?: number\n  /**\n   * Should be multiple of 100 eg. 100,200....\n   */\n  animationLength?: number\n  scrollerRef?: RefObject<HTMLElement>\n}\n\nfunction ScrollingCards({\n  cards,\n  cardWidth,\n  top = 45,\n  left = 20,\n  animationLength = 300,\n  scrollerRef,\n}: CardSliderProps) {\n  const sectionRef = useRef<HTMLElement>(null)\n  const cardsRef = useRef<HTMLDivElement[]>([])\n \n\n \n  useGSAP(() => {\n    if (!sectionRef.current || !cardsRef.current) return\n    \n    const unitLeftDis = (50 - left) / cards.length\n    // Set initial position for all cards (below viewport)\n    gsap.set(cardsRef.current, {\n      top: window.innerHeight + 300,\n      rotate: (i) => `${cards[i].rotate}deg`,\n    })\n    const innerTl = gsap.timeline({\n      scrollTrigger: {\n        trigger: sectionRef.current,\n        start: \"center center\", // Start when section center hits viewport center\n        end: `+=${animationLength}%`, // End after scrolling 300% of section height\n        scrub: true, // Smooth scrubbing effect\n        markers: false, // Set to\n    \n     \n      },\n    })\n    // Create timeline for sequential animation\n    const tl = gsap.timeline({\n      scrollTrigger: {\n        trigger: sectionRef.current,\n        start: \"center center\", // Start when section center hits viewport center\n        end: \"+=300%\", // End after scrolling 300% of section height\n        pin: true, // Pin the section while animation plays\n        pinSpacing:true,\n        scrub: 1, // Smooth scrubbing effect\n   \n        markers:false,\n      \n        onUpdate: (self) => {\n          const direction = self.direction\n          const topCards = cardsRef.current.filter((card) => {\n            if (card.offsetTop /(scrollerRef?.current?.getBoundingClientRect().height|| window.innerHeight )<= top / 100) return true\n            else return false\n          })\n\n          if (direction == 1) {\n            innerTl.clear()\n            innerTl.to(\n              topCards,\n              {\n                left: (i) => {\n                  return `${i * unitLeftDis + left}%`\n                },\n              },\n              \"<\"\n            )\n          } else {\n            innerTl.clear()\n            innerTl.to(topCards, {\n              left: \"50%\",\n            })\n          }\n        },\n      },\n    })\n\n    // Add each card to the timeline with sequential animation\n    cardsRef.current.forEach((card) => {\n      if (!card) return\n\n      tl.to(\n        card,\n        {\n          top: `${top}%`,\n          ease: \"none\",\n        },\n        \">\"\n      ) // Stagger the animations\n    })\n  }, [cards, cardsRef.current])\n\n  return (\n    <section\n      ref={sectionRef}\n      className=\"h-screen relative flex items-center justify-center overflow-hidden\"\n    >\n      {cards.map((item, index) => (\n        <div\n          key={index}\n          ref={(el) => {\n            if (el) cardsRef.current[index] = el\n          }}\n          style={{\n            rotate: `${item.rotate}deg`,\n            transformOrigin: `${\n              item.transformOrigin ?? `${index % 2 === 0 ? \"left\" : \"right\"}`\n            }`,\n            width: `${cardWidth}px`,\n            position: \"absolute\",\n          }}\n          className=\"transition-all  -translate-x-1/2 -translate-y-1/2 left-1/2  top-full\"\n        >\n          {item.card}\n        </div>\n      ))}\n    </section>\n  )\n}\n\nfunction SnappingScrollingCards({\n  cards,\n  cardWidth,\n  top = 35,\n  left = 30,\n  animationLength = 400,\n  scrollerRef,\n}: CardSliderProps) {\n  const sectionRef = useRef<HTMLElement>(null)\n  const cardsRef = useRef<HTMLDivElement[]>([])\n\n\n  useGSAP(() => {\n    if (!sectionRef.current || cardsRef.current.some((ref) => !ref)) return\n\n\n   \n\n \n    const unitLeftDis = (50 - left) / (cards.length - 1 || 1)\n\n    // Calculate maximum rotation to adjust starting position\n    const maxRotation = Math.max(...cards.map((card) => Math.abs(card.rotate)))\n    const extraPadding = maxRotation * 2 // Add extra padding based on rotation\n\n    // Reset all cards to initial position - move them further down to account for rotation\n    gsap.set(cardsRef.current, {\n      top: window.innerHeight + 300 + extraPadding,\n      left: \"50%\",\n      rotate: (i) => `${cards[i]?.rotate || 0}deg`,\n      opacity: 0, // Start with opacity 0\n      clearProps: \"none\", // Clear any previously set props\n    })\n\n    // Create main scroll trigger\n    const st = ScrollTrigger.create({\n      trigger: sectionRef.current,\n      start: \"center center\",\n      end: `+=${animationLength}%`,\n      pin: true,\n      scrub: 1,\n      onUpdate: (self) => {\n        // Calculate current scroll progress (0-1)\n        const progress = self.progress\n\n        // Total scroll is divided into sections:\n        // - First 70% of scroll brings cards up sequentially\n        // - Remaining 30% ensures all cards reach final horizontal position\n\n        const verticalSection = 0.7 // 70% of scroll dedicated to vertical movement\n\n        cardsRef.current.forEach((card, i) => {\n          if (!card) return\n\n          // Calculate when this card should start its vertical animation\n          // (distributed evenly across the first 70% of scroll)\n          const cardStartPoint = (i / cards.length) * verticalSection\n\n          // Calculate progress of this card's animation sequence (0-1)\n          let cardProgress =\n            (progress - cardStartPoint) / (verticalSection / cards.length)\n          cardProgress = Math.max(0, Math.min(1, cardProgress))\n\n          // Calculate vertical position\n          const verticalProgress = Math.min(1, cardProgress * 2) // Complete vertical movement in first half of card's sequence\n          const startY = window.innerHeight + 300 + extraPadding\n          const endY = (window.innerHeight * top) / 100\n          const topPosition = startY - (startY - endY) * verticalProgress\n\n          // Calculate horizontal position (starts when vertical is halfway done)\n          let horizontalProgress = 0\n          if (cardProgress > 0.5) {\n            // Map 0.5-1 to 0-1 for horizontal animation\n            horizontalProgress = (cardProgress - 0.5) * 2\n\n            // Use eased progress based on overall scroll progress to ensure all cards finish together\n            // When overall progress reaches 1, all cards should be at their final position\n            const masterProgress = Math.min(1, progress / 1)\n            horizontalProgress = Math.min(horizontalProgress, masterProgress)\n          }\n\n          // Calculate final left position\n          const leftPos =\n            50 - (50 - (left + i * unitLeftDis)) * horizontalProgress\n\n          // Apply transforms directly\n          gsap.set(card, {\n            top: topPosition,\n            left: `${leftPos}%`,\n            opacity: cardProgress > 0 ? 1 : 0, // Fade in when animation starts\n          })\n        })\n      },\n    })\n\n    return () => {\n      st.kill()\n    }\n  }, [cards, cardWidth, top, left])\n\n  return (\n    <section\n      ref={sectionRef}\n      className=\"h-screen relative flex items-center justify-center overflow-hidden\"\n    >\n      {cards.map((item, index) => (\n        <div\n          key={index}\n          ref={(el) => {\n            if (el) cardsRef.current[index] = el\n          }}\n          style={{\n            rotate: `${item.rotate}deg`,\n            transformOrigin:\n              item.transformOrigin || (index % 2 === 0 ? \"left\" : \"right\"),\n            width: `${cardWidth}px`,\n            position: \"absolute\",\n          }}\n          className=\"transition-all -translate-x-1/2 -translate-y-1/2\"\n        >\n          {item.card}\n        </div>\n      ))}\n    </section>\n  )\n}\nexport { ScrollingCards, SnappingScrollingCards }\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "categories": [
    "hover-effect"
  ]
}