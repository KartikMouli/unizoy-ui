{
  "$schema": "https://ui.unizoy.com/schema/registry-item.json",
  "name": "image-trail",
  "type": "registry:ui",
  "author": "shadcn (https://ui.unizoy.com)",
  "dependencies": [
    "gsap",
    "@gsap/react"
  ],
  "files": [
    {
      "path": "ui/image-trail.tsx",
      "content": "\"use client\"\nimport { useGSAP } from \"@gsap/react\"\nimport gsap from \"gsap\"\nimport React, { useEffect, useRef, useState, useCallback } from \"react\"\n\ninterface Image {\n  id: number\n  x: number\n  y: number\n  url: string\n  timestamp: number\n  isExpiring?: boolean // Flag to track images that are fading out\n}\n\ninterface ImageTrailProps {\n  images: string[]\n  text: string\n  duration?: number\n  fadeOutDuration?: number\n  spawnInterval?: number\n  renderRadius?: number\n  maxImages?: number\n  easeForMovement?: string\n}\n\nexport const ImageTrail: React.FC<ImageTrailProps> = ({\n  images,\n  text,\n  duration = 1,\n  spawnInterval = 0,\n  renderRadius = 90,\n  maxImages = 5,\n  fadeOutDuration = 0.5,\n  easeForMovement = \"none\",\n}) => {\n  const [activeImages, setActiveImages] = useState<Image[]>([])\n  const [imageIndex, setImageIndex] = useState(0)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const lastSpawnTimeRef = useRef(0)\n  const lastPositionRef = useRef({ x: 0, y: 0 })\n  const imageIdCounter = useRef(0)\n  const MAX_IMAGES = maxImages\n  const imagesRef = useRef<HTMLDivElement>(null)\n  const isTouchActiveRef = useRef(false)\n\n  // Remove images that have completed their fade-out animation\n  const removeExpiredImages = useCallback(() => {\n    const now = performance.now()\n    const timeToRemove = duration * 1000 - fadeOutDuration * 1000 // Start fading 1 second before removal\n\n    setActiveImages((prev) => {\n      // First, mark images that need to start fading\n      const updatedImages = prev.map((img) => {\n        if (now - img.timestamp > timeToRemove && !img.isExpiring) {\n          // Start fade animation for this image\n          const imgElement = imagesRef.current?.querySelector(\n            `[data-id=\"${img.id}\"]`\n          )\n          if (imgElement && !imgElement.classList.contains(\"fading\")) {\n            imgElement.classList.add(\"fading\")\n            gsap.to(imgElement, {\n              opacity: 0,\n              duration: fadeOutDuration,\n              ease: \"power2.out\",\n            })\n          }\n          return { ...img, isExpiring: true }\n        }\n        return img\n      })\n\n      // Then remove images that have completed their fade-out animation\n      return updatedImages.filter(\n        (img) => now - img.timestamp < duration * 1000\n      )\n    })\n  }, [duration, fadeOutDuration])\n\n  useGSAP(\n    () => {\n      if (!imagesRef.current) return\n\n      const images = imagesRef.current.querySelectorAll(\"img:not(.fading)\")\n      if (!images || images.length <= 0) return\n\n      const latestImage = images[images.length - 1]\n\n      // If it's the first image, use the cursor's position\n      const prevImage =\n        activeImages.length > 1 ? activeImages[activeImages.length - 2] : null\n      const startX = prevImage ? prevImage.x : lastPositionRef.current.x\n      const startY = prevImage ? prevImage.y : lastPositionRef.current.y\n\n      gsap.fromTo(\n        latestImage,\n        {\n          left: startX,\n          top: startY,\n          opacity: 1,\n        },\n        {\n          left: lastPositionRef.current.x,\n          top: lastPositionRef.current.y,\n          duration: 0.3,\n          ease: easeForMovement,\n        }\n      )\n    },\n    { dependencies: [imageIndex], scope: containerRef }\n  )\n\n  useEffect(() => {\n    const intervalId = setInterval(removeExpiredImages, 100)\n    return () => clearInterval(intervalId)\n  }, [removeExpiredImages])\n\n  // Set up global touch event handling to prevent scrolling while interacting with our component\n  useEffect(() => {\n    const preventScroll = (e: TouchEvent) => {\n      if (isTouchActiveRef.current && containerRef.current) {\n        e.preventDefault()\n      }\n    }\n\n    // Add the event listener with passive: false to allow preventDefault()\n    document.addEventListener('touchmove', preventScroll, { passive: false })\n    \n    return () => {\n      document.removeEventListener('touchmove', preventScroll)\n    }\n  }, [])\n\n  const getDistance = (x1: number, y1: number, x2: number, y2: number) => {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))\n  }\n\n  const addImage = (x: number, y: number) => {\n    const now = performance.now()\n    if (now - lastSpawnTimeRef.current < spawnInterval) {\n      return\n    }\n\n    const distance = getDistance(\n      x,\n      y,\n      lastPositionRef.current.x,\n      lastPositionRef.current.y\n    )\n    if (distance < renderRadius && activeImages.length > 0) {\n      return\n    }\n\n    // If it's the first image, ensure lastPositionRef is updated\n    if (activeImages.length === 0) {\n      lastPositionRef.current = { x, y }\n    }\n\n    lastSpawnTimeRef.current = now\n    lastPositionRef.current = { x, y }\n\n    const newImage: Image = {\n      id: imageIdCounter.current++,\n      x,\n      y,\n      url: images[imageIndex],\n      timestamp: now,\n    }\n\n    setActiveImages((prev) => {\n      let newImages = [...prev, newImage]\n\n      // If we're about to exceed MAX_IMAGES, mark the oldest for fading out\n      if (newImages.length > MAX_IMAGES) {\n        const oldestImage = newImages[0]\n\n        // Only start fading if it's not already expiring\n        if (!oldestImage.isExpiring) {\n          // Mark it as expiring\n          newImages[0] = { ...oldestImage, isExpiring: true }\n\n          // Start fade-out animation\n          const imgElement = imagesRef.current?.querySelector(\n            `[data-id=\"${oldestImage.id}\"]`\n          )\n          if (imgElement) {\n            imgElement.classList.add(\"fading\")\n            gsap.to(imgElement, {\n              opacity: 0,\n              duration: fadeOutDuration,\n              ease: \"none\",\n            })\n          }\n        }\n\n        // we keep the expiring image\n        // until its fade-out animation completes\n        if (newImages.length > MAX_IMAGES + 3) {\n          // But we do limit how many fading images we keep to avoid memory issues\n          newImages = newImages.slice(-(MAX_IMAGES + 3))\n        }\n      }\n\n      return newImages\n    })\n\n    setImageIndex((prev) => (prev + 1) % images.length)\n  }\n\n  const handlePointerEvent = (x: number, y: number) => {\n    if (!imagesRef.current) return\n    const rect = imagesRef.current.getBoundingClientRect()\n    const relativeX = x - rect.left\n    const relativeY = y - rect.top\n    addImage(relativeX, relativeY)\n  }\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    handlePointerEvent(e.clientX, e.clientY)\n  }\n\n  const handleTouchMove = (e: React.TouchEvent) => {\n    // Get the first touch point\n    const touch = e.touches[0]\n    if (touch) {\n      handlePointerEvent(touch.clientX, touch.clientY)\n    }\n  }\n\n  const handleTouchStart = (e: React.TouchEvent) => {\n    // Set the touch as active to prevent scrolling\n    isTouchActiveRef.current = true\n    \n    const touch = e.touches[0]\n    if (touch) {\n      handlePointerEvent(touch.clientX, touch.clientY)\n    }\n  }\n\n  const handleTouchEnd = () => {\n    // Touch is no longer active, allow scrolling again\n    isTouchActiveRef.current = false\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"relative w-full h-full overflow-hidden touch-none\"\n      onMouseMove={handleMouseMove}\n      onTouchMove={handleTouchMove}\n      onTouchStart={handleTouchStart}\n      onTouchEnd={handleTouchEnd}\n      onTouchCancel={handleTouchEnd}\n    >\n      {/* Canvas Layer */}\n      <div className=\"absolute inset-0\" ref={imagesRef}>\n        {activeImages.map((img) => (\n          <img\n            key={img.id}\n            data-id={img.id}\n            src={img.url}\n            alt=\"\"\n            className={`absolute images pointer-events-none ${img.isExpiring ? \"fading\" : \"\"}`}\n            style={{\n              left: `${img.x}px`,\n              top: `${img.y}px`,\n              width: \"100px\",\n              height: \"100px\",\n              objectFit: \"cover\",\n              opacity: img.isExpiring ? undefined : 1, // Let the animation handle opacity for expiring images\n            }}\n          />\n        ))}\n      </div>\n\n      {/* Text Layer */}\n      <div className=\"relative z-10 w-full h-full flex items-center justify-center\">\n        <h1 className=\" text-xl sm:text2xl md:text4xl lg:text-6xl font-bold dark:text-white text-black mix-blend-difference\">\n          {text}\n        </h1>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "categories": [
    "hover-effect"
  ]
}