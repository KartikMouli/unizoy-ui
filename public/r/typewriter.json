{
  "$schema": "https://ui.unizoy.com/schema/registry-item.json",
  "name": "typewriter",
  "type": "registry:ui",
  "author": "shadcn (https://ui.unizoy.com)",
  "dependencies": [
    "gsap",
    "@gsap/react"
  ],
  "files": [
    {
      "path": "ui/typewriter.tsx",
      "content": "\"use client\"\n\nimport { forwardRef, useRef, HTMLAttributes, useEffect, useState } from \"react\"\nimport gsap from \"gsap\"\nimport { cn, mergeRefs } from \"../lib/utils\"\nimport { useGSAP } from \"@gsap/react\"\nimport { ScrollTrigger } from \"gsap/ScrollTrigger\"\n\ngsap.registerPlugin(ScrollTrigger)\ntype TextAndClass = {\n  text: string\n  className?: string\n}\n\ninterface TypeWriterProps extends HTMLAttributes<HTMLDivElement> {\n  staticText: TextAndClass[]\n  textArray?: TextAndClass[]\n  delay?: number\n  duration?: number\n  ease?: gsap.EaseString | gsap.EaseFunction\n  className?: string\n  start?: string | number | ((tag?: ScrollTrigger) => string | number)\n  end?: string | number | ((tag?: ScrollTrigger) => string | number)\n  arrayInterval?: number\n  deleteSpeed?: number\n}\n\nconst TypeWriter = forwardRef<HTMLDivElement, TypeWriterProps>(\n  (\n    {\n      staticText,\n      textArray,\n      children,\n      delay = 0,\n      start = \"top 90%\",\n      end = \"top\",\n      duration = 0.5,\n      ease = \"none\",\n      className = \"\",\n      arrayInterval = 3000,\n      deleteSpeed = 0.1,\n      ...props\n    },\n    ref\n  ) => {\n    const containerRef = useRef<HTMLDivElement>(null)\n    const textRef = useRef<HTMLDivElement>(null)\n    const [currentArrayText, setCurrentArrayText] = useState(\"\")\n    const [arrayIndex, setArrayIndex] = useState(0)\n    const [isDeleting, setIsDeleting] = useState(false)\n    const [mainTextComplete, setMainTextComplete] = useState(false)\n\n    // Handle the main text animation\n    useGSAP(\n      () => {\n        if (!textRef.current) return\n\n        const animation = gsap.from(textRef.current, {\n          width: 0,\n          duration: duration || staticText.length * 0.3,\n          delay,\n          ease,\n          onComplete: () => setMainTextComplete(true),\n          scrollTrigger: {\n            trigger: textRef.current,\n            start,\n            end,\n            toggleActions: \"play none none reset\",\n            onLeaveBack: () => setMainTextComplete(false),\n          },\n        })\n\n        return () => {\n          animation.kill()\n        }\n      },\n      {\n        dependencies: [staticText, delay, start, end, duration, ease],\n        scope: containerRef,\n      }\n    )\n\n    // Handle the textArray animations\n    useEffect(() => {\n      if (!textArray?.length || !mainTextComplete) return\n\n      let timeout: ReturnType<typeof setTimeout>\n      let isActive = true // Flag to prevent state updates after unmount\n\n      const animateText = () => {\n        if (!isActive) return\n\n        if (isDeleting) {\n          if (currentArrayText.length > 0) {\n            setCurrentArrayText((prev) => prev.slice(0, -1))\n            timeout = setTimeout(animateText, deleteSpeed * 1000)\n          } else {\n            setIsDeleting(false)\n            setArrayIndex((prev) => (prev + 1) % textArray.length)\n          }\n        } else {\n          const targetText = textArray[arrayIndex].text\n          if (currentArrayText.length < targetText.length) {\n            setCurrentArrayText((prev) => targetText.slice(0, prev.length + 1))\n            timeout = setTimeout(animateText, deleteSpeed * 1000)\n          } else {\n            timeout = setTimeout(\n              () => isActive && setIsDeleting(true),\n              arrayInterval\n            )\n          }\n        }\n      }\n\n      timeout = setTimeout(\n        animateText,\n        currentArrayText.length === 0 ? 0 : deleteSpeed * 1000\n      )\n\n      return () => {\n        isActive = false\n        clearTimeout(timeout)\n      }\n    }, [\n      textArray,\n      arrayIndex,\n      currentArrayText,\n      isDeleting,\n      arrayInterval,\n      deleteSpeed,\n      mainTextComplete,\n    ])\n\n    // Reset array text when main animation resets\n    useEffect(() => {\n      if (!mainTextComplete) {\n        setCurrentArrayText(\"\")\n        setArrayIndex(0)\n        setIsDeleting(false)\n      }\n    }, [mainTextComplete])\n\n    return (\n      <div\n        ref={mergeRefs(ref, containerRef)}\n        className={cn(\"flex flex-col gap-2\", className)}\n        {...props}\n      >\n        <div className=\"flex items-center animate-blinkBorder border-r-2 pr-1\">\n          <div ref={textRef} className=\"flex  text-nowrap overflow-hidden \">\n            {staticText.map((data, i) => (\n              <span key={`staticText-${i}`} className={cn(data.className)}>\n                {data.text}&nbsp;\n              </span>\n            ))}\n          </div>\n          {textArray && (\n            <div className={cn(textArray[arrayIndex]?.className)}>\n              {currentArrayText}\n            </div>\n          )}\n        </div>\n      </div>\n    )\n  }\n)\n\nTypeWriter.displayName = \"TypeWriter\"\n\nexport { TypeWriter }\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "categories": [
    "hover-effect"
  ]
}