{
  "$schema": "https://ui.unizoy.com/schema/registry-item.json",
  "name": "rotating-text",
  "type": "registry:ui",
  "author": "shadcn (https://ui.unizoy.com)",
  "dependencies": [
    "gsap",
    "@gsap/react"
  ],
  "files": [
    {
      "path": "ui/rotating-text.tsx",
      "content": "\"use client\"\nimport { RefObject, useEffect, useRef, useState } from \"react\"\nimport gsap from \"gsap\"\nimport ScrollTrigger from \"gsap/ScrollTrigger\"\nimport { useGSAP } from \"@gsap/react\"\nimport { cn } from \"../lib/utils\"\ngsap.registerPlugin(ScrollTrigger)\ninterface RotatingTextProps {\n  text: { data: string; className?: string }[]\n  scrollerRef?: RefObject<HTMLElement>\n  start?: string | number | ScrollTrigger.StartEndFunc\n  end?: string | number | ScrollTrigger.StartEndFunc\n  scrub?: number | boolean\n  markers?: boolean | ScrollTrigger.MarkersVars\n  className?: string\n}\nconst RotatingText = ({\n  text,\n  scrollerRef,\n  start = \"top top\",\n  end = \"+=300\",\n  scrub = 1,\n  markers = false,\n  className,\n}: RotatingTextProps) => {\n  const mainRef = useRef<HTMLDivElement>(null)\n  const textRef = useRef<HTMLSpanElement[]>([])\n  const instanceIdRef = useRef<string>(\n    `rotating-text-${Math.random().toString(36).substring(2, 11)}`\n  )\n  const [forceUpdate, setForceUpdate] = useState(false)\n\n  useEffect(() => {\n    console.log(\"from useEffext\");\n    \n    if (scrollerRef?.current) {\n      setForceUpdate(!forceUpdate)\n    }\n  }, [scrollerRef?.current])\n  useGSAP(() => {\n    console.log(\"from use Gsap\");\n    \n    if (!mainRef.current && !textRef.current) return\n\n    // Kill only this component's ScrollTrigger instance if it exists\n    const existingTrigger = ScrollTrigger.getById(instanceIdRef.current)\n    if (existingTrigger) {\n      existingTrigger.kill()\n    }\n\n    const tl = gsap.timeline({\n      scrollTrigger: {\n        trigger: mainRef.current,\n        start,\n        end,\n        scrub,\n        pin: true,\n        scroller: scrollerRef?.current ?? window,\n        markers,\n        id: instanceIdRef.current,\n      },\n    })\n    tl.set(textRef.current, {\n      rotationY: (index) =>\n        index % 2 === 0\n          ? gsap.utils.random(150, 180, 1)\n          : gsap.utils.random(-180, -150, 1),\n      scale: 0,\n      transformOrigin: (index) => (index % 2 === 0 ? \"bottom\" : \"top\"),\n    })\n\n    tl.to(textRef.current, {\n      scale: 1,\n      rotationY: 0,\n      ease: \"none\",\n      stagger: {\n        amount: 0.5,\n        from: \"random\",\n      },\n    })\n\n    return () => {\n      // Cleanup ScrollTrigger instances when component unmounts\n\n      const triggerToKill = ScrollTrigger.getById(instanceIdRef.current)\n      if (triggerToKill) {\n        triggerToKill.kill()\n      }\n    }\n  }, [text, start, end, scrub, markers, forceUpdate])\n\n  const charOffsets = text.reduce<number[]>((acc, item, i) => {\n    const prev = acc[i - 1] ?? 0\n    const newCount = item.data.length + prev\n    return [...acc, newCount]\n  }, [])\n\n  return (\n    <div\n      ref={mainRef}\n      className={cn(\n        \" h-screen text-9xl\",\n        className,\n        \" flex justify-center items-center  \"\n      )}\n      style={{ perspective: \"800px\" }}\n    >\n      <div>\n        {text.map((t, rowIndex) => (\n          <div key={rowIndex} className={cn(t.className, \"text-center\")}>\n            {t.data.split(\"\").map((char, charIndex) => {\n              const globalIndex =\n                charIndex + (rowIndex > 0 ? charOffsets[rowIndex - 1] : 0)\n              return (\n                <span\n                  key={charIndex}\n                  style={{\n                    display: \"inline-block\",\n                    transformStyle: \"preserve-3d\",\n                  }}\n                  ref={(el) => {\n                    if (el) textRef.current[globalIndex] = el\n                  }}\n                >\n                  {char === \" \" ? \"\\u00A0\" : char}\n                </span>\n              )\n            })}\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n\nexport default RotatingText\n// \"use client\"\n\n// import { RefObject, useEffect, useRef, useState } from \"react\"\n// import gsap from \"gsap\"\n// import ScrollTrigger from \"gsap/ScrollTrigger\"\n// import { useGSAP } from \"@gsap/react\"\n// import { cn } from \"../lib/utils\"\n\n// gsap.registerPlugin(ScrollTrigger)\n\n// interface RotatingTextProps {\n//   text: { data: string; className?: string }[]\n//   scrollerRef?: RefObject<HTMLElement>\n//   start?: string | number | ScrollTrigger.StartEndFunc\n//   end?: string | number | ScrollTrigger.StartEndFunc\n//   scrub?: number | boolean\n//   markers?: boolean | ScrollTrigger.MarkersVars\n//   className?: string\n// }\n\n// const RotatingText = ({\n//   text,\n//   scrollerRef,\n//   start = \"top top\",\n//   end = \"+=300\",\n//   scrub = 1,\n//   markers = false,\n//   className,\n// }: RotatingTextProps) => {\n//   const mainRef = useRef<HTMLDivElement>(null)\n//   const textRef = useRef<HTMLSpanElement[]>([])\n//   const scrollTriggerRef = useRef<ScrollTrigger | null>(null)\n//   const timelineRef = useRef<gsap.core.Timeline | null>(null)\n\n//   // This ensures we recreate the animation whenever the scroller changes\n//   const [scrollerReady, setScrollerReady] = useState(false)\n\n//   // Monitor when the scrollerRef is ready (either not provided or actual element available)\n//   useEffect(() => {\n//     if (!scrollerRef || scrollerRef.current) {\n//       console.log(\"Scroller is ready:\", scrollerRef?.current || \"window\");\n//       setScrollerReady(true);\n//     } else {\n//       setScrollerReady(false);\n//     }\n//   }, [scrollerRef?.current]);\n\n//   // Clean up previous animation before creating a new one\n//   useEffect(() => {\n//     return () => {\n//       // Clean up when component unmounts\n//       if (scrollTriggerRef.current) {\n//         console.log(\"Killing previous ScrollTrigger instance\");\n//         scrollTriggerRef.current.kill();\n//         scrollTriggerRef.current = null;\n//       }\n\n//       if (timelineRef.current) {\n//         timelineRef.current.kill();\n//         timelineRef.current = null;\n//       }\n//     };\n//   }, []);\n\n//   // Create the animation when everything is ready\n//   useEffect(() => {\n//     if (!mainRef.current || textRef.current.length === 0 || !scrollerReady) return;\n\n//     // Clean up previous instance if it exists\n//     if (scrollTriggerRef.current) {\n//       console.log(\"Killing previous ScrollTrigger instance\");\n//       scrollTriggerRef.current.kill();\n//       scrollTriggerRef.current = null;\n//     }\n\n//     if (timelineRef.current) {\n//       timelineRef.current.kill();\n//       timelineRef.current = null;\n//     }\n\n//     console.log(\"Creating new ScrollTrigger with scroller:\", scrollerRef?.current || \"window\");\n\n//     // Create a new timeline\n//     const tl = gsap.timeline({\n//       scrollTrigger: {\n//         trigger: mainRef.current,\n//         start,\n//         end,\n//         scrub,\n//         pin: true,\n//         scroller: scrollerRef?.current || undefined, // undefined defaults to window\n//         markers,\n//         id: \"rotatingTextTrigger\", // Add an ID for easier debugging\n//       },\n//     });\n\n//     // Store the ScrollTrigger instance for later cleanup\n//     scrollTriggerRef.current = ScrollTrigger.getById(\"rotatingTextTrigger\") as ScrollTrigger;\n//     timelineRef.current = tl;\n\n//     // Set up the animation\n//     tl.set(textRef.current, {\n//       rotationY: (index) =>\n//         index % 2 === 0\n//           ? gsap.utils.random(150, 180, 1)\n//           : gsap.utils.random(-180, -150, 1),\n//       scale: 0,\n//       transformOrigin: (index) => (index % 2 === 0 ? \"bottom\" : \"top\"),\n//     });\n\n//     tl.to(textRef.current, {\n//       scale: 1,\n//       rotationY: 0,\n//       ease: \"none\",\n//       stagger: {\n//         amount: 0.5,\n//         from: \"random\",\n//       },\n//     });\n\n//   }, [text, start, end, scrub, markers, scrollerReady]);\n\n//   // Reset textRef when text content changes\n//   useEffect(() => {\n//     textRef.current = [];\n//   }, [text]);\n\n//   const charOffsets = text.reduce<number[]>((acc, item, i) => {\n//     const prev = acc[i - 1] ?? 0\n//     const newCount = item.data.length + prev\n//     return [...acc, newCount]\n//   }, [])\n\n//   return (\n//     <div\n//       ref={mainRef}\n//       className={cn(\n//         \"h-screen text-9xl\",\n//         className,\n//         \"flex justify-center items-center\"\n//       )}\n//       style={{ perspective: \"800px\" }}\n//     >\n//       <div>\n//         {text.map((t, rowIndex) => (\n//           <div key={rowIndex} className={cn(t.className, \"text-center\")}>\n//             {t.data.split(\"\").map((char, charIndex) => {\n//               const globalIndex =\n//                 charIndex + (rowIndex > 0 ? charOffsets[rowIndex - 1] : 0)\n//               return (\n//                 <span\n//                   key={charIndex}\n//                   style={{\n//                     display: \"inline-block\",\n//                     transformStyle: \"preserve-3d\",\n//                   }}\n//                   ref={(el) => {\n//                     if (el) textRef.current[globalIndex] = el\n//                   }}\n//                 >\n//                   {char === \" \" ? \"\\u00A0\" : char}\n//                 </span>\n//               )\n//             })}\n//           </div>\n//         ))}\n//       </div>\n//     </div>\n//   )\n// }\n\n// export default RotatingText\n// \"use client\"\n\n// import { RefObject, useEffect, useRef, useState } from \"react\"\n// import gsap from \"gsap\"\n// import ScrollTrigger from \"gsap/ScrollTrigger\"\n// import { useGSAP } from \"@gsap/react\"\n// import { cn } from \"../lib/utils\"\n\n// gsap.registerPlugin(ScrollTrigger)\n\n// interface RotatingTextProps {\n//   text: { data: string; className?: string }[]\n//   scrollerRef?: RefObject<HTMLElement>\n//   start?: string | number | ScrollTrigger.StartEndFunc\n//   end?: string | number | ScrollTrigger.StartEndFunc\n//   scrub?: number | boolean\n//   markers?: boolean | ScrollTrigger.MarkersVars\n//   className?: string\n// }\n\n// const RotatingText = ({\n//   text,\n//   scrollerRef,\n//   start = \"top top\",\n//   end = \"+=300\",\n//   scrub = 1,\n//   markers = false,\n//   className,\n// }: RotatingTextProps) => {\n//   const mainRef = useRef<HTMLDivElement>(null)\n//   const textRef = useRef<HTMLSpanElement[]>([])\n//   const [scrollerReady, setScrollerReady] = useState(false)\n\n//   // Monitor when the scrollerRef is ready\n//   useEffect(() => {\n//     if (!scrollerRef || scrollerRef.current) {\n//       console.log(\"Scroller is ready:\", scrollerRef?.current || \"window\");\n//       setScrollerReady(true);\n//     } else {\n//       setScrollerReady(false);\n//     }\n//   }, [scrollerRef?.current]);\n\n//   // Reset textRef when text content changes\n//   useEffect(() => {\n//     textRef.current = [];\n//   }, [text]);\n\n//   // Use the useGSAP hook for animation\n//   useGSAP(() => {\n//     if (!mainRef.current || textRef.current.length === 0) return;\n\n//     // Clean up any previous ScrollTrigger instances related to this component\n//     ScrollTrigger.getAll().forEach(st => {\n//       if (st.vars.trigger === mainRef.current) {\n//         console.log(\"Killing existing ScrollTrigger\");\n//         st.kill();\n//       }\n//     });\n\n//     console.log(\"Creating new ScrollTrigger with scroller:\", scrollerRef?.current || \"window\");\n\n//     // Create a new timeline with ScrollTrigger\n//     const tl = gsap.timeline({\n//       scrollTrigger: {\n//         trigger: mainRef.current,\n//         start,\n//         end,\n//         scrub,\n//         pin: true,\n//         scroller: scrollerRef?.current || undefined, // undefined defaults to window\n//         markers,\n//         id: \"rotatingTextTrigger\",\n//       },\n//     });\n\n//     // Set up the animation\n//     tl.set(textRef.current, {\n//       rotationY: (index) =>\n//         index % 2 === 0\n//           ? gsap.utils.random(150, 180, 1)\n//           : gsap.utils.random(-180, -150, 1),\n//       scale: 0,\n//       transformOrigin: (index) => (index % 2 === 0 ? \"bottom\" : \"top\"),\n//     });\n\n//     tl.to(textRef.current, {\n//       scale: 1,\n//       rotationY: 0,\n//       ease: \"none\",\n//       stagger: {\n//         amount: 0.5,\n//         from: \"random\",\n//       },\n//     });\n\n//     // Return cleanup function\n//     return () => {\n//       console.log(\"Cleaning up animations\");\n//       ScrollTrigger.getAll().forEach(st => {\n//         if (st.vars.trigger === mainRef.current) {\n//           st.kill();\n//         }\n//       });\n//     };\n//   }, [text, start, end, scrub, markers, scrollerReady]); // Include scrollerReady in dependencies\n\n//   const charOffsets = text.reduce<number[]>((acc, item, i) => {\n//     const prev = acc[i - 1] ?? 0\n//     const newCount = item.data.length + prev\n//     return [...acc, newCount]\n//   }, [])\n\n//   return (\n//     <div\n//       ref={mainRef}\n//       className={cn(\n//         \"h-screen text-9xl\",\n//         className,\n//         \"flex justify-center items-center\"\n//       )}\n//       style={{ perspective: \"800px\" }}\n//     >\n//       <div>\n//         {text.map((t, rowIndex) => (\n//           <div key={rowIndex} className={cn(t.className, \"text-center\")}>\n//             {t.data.split(\"\").map((char, charIndex) => {\n//               const globalIndex =\n//                 charIndex + (rowIndex > 0 ? charOffsets[rowIndex - 1] : 0)\n//               return (\n//                 <span\n//                   key={charIndex}\n//                   style={{\n//                     display: \"inline-block\",\n//                     transformStyle: \"preserve-3d\",\n//                   }}\n//                   ref={(el) => {\n//                     if (el) textRef.current[globalIndex] = el\n//                   }}\n//                 >\n//                   {char === \" \" ? \"\\u00A0\" : char}\n//                 </span>\n//               )\n//             })}\n//           </div>\n//         ))}\n//       </div>\n//     </div>\n//   )\n// }\n\n// export default RotatingText\n",
      "type": "registry:ui",
      "target": ""
    }
  ],
  "categories": [
    "hover-effect"
  ]
}